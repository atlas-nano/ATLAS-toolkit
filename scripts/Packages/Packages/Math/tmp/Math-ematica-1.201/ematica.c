/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of ematica.xs. Do not edit this file, edit ematica.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "ematica.xs"
/*                               -*- Mode: C -*- 
 * $Basename: ematica.xs $
 * $Revision: 1.23 $
 * Author          : Ulrich Pfeifer
 * Created On      : Sat Dec 20 15:18:26 1997
 * Last Modified By: Ulrich Pfeifer
 * Last Modified On: Tue Apr 26 16:53:01 2005
 * Language        : C
 * Update Count    : 266
 * Status          : Unknown, Use with caution!
 * 
 * (C) Copyright 1997, Ulrich Pfeifer, all rights reserved.
 * 
 */

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#ifdef __cplusplus
}
#endif

#include <mathlink.h>
#include "constants.h"

/* Class for Mathematica Symbols */
#define SYMNAME "Math::ematica::symbol"

MLENV env = NULL;

static void
error(long merrno)
{
  croak("Mathematica error %ld: %s\n", merrno, MLErrorString(env, merrno));
}

static SV *
make_symbol(char * name)
{
  SV * result = newRV_noinc(newSVpv(name,0));
  sv_bless(result, gv_stashpv(SYMNAME,1));
  return (result);
}

static SV *
read_packet (MLINK link)
{
  mlapi_token token;
  SV *RETVAL = NULL;

  token = MLGetNext (link);
  switch (token) {
  case MLTKREAL:{
      double real;

      if (!MLGetDouble (link, &real))
	return (RETVAL);
      RETVAL = newSVnv (real);
      break;
    }
  case MLTKINT:{
      int integer;

      if (!MLGetInteger (link, &integer))
	return (RETVAL);
      RETVAL = newSViv (integer);
      break;
    }
  case MLTKSTR:{
      kcharp_ct string;

      if (!MLGetString (link, &string))
	return (RETVAL);
      RETVAL = newSVpv ((char *) string, 0);
      MLDisownString (link, string);
      break;
    }
  case MLTKSYM:{
      kcharp_ct string;

      if (!MLGetSymbol (link, &string))
	return (RETVAL);
      RETVAL = make_symbol ((char *) string);
      MLDisownSymbol (link, string);
      break;
    }
  case MLTKFUNC:{
      kcharp_ct string;
      long_st nargs;
      long_st i;
      long_st j = 0;
      AV * array;

      if (!MLGetFunction (link, &string, &nargs))
	return (&PL_sv_undef);

      array = newAV ();
      av_extend(array, nargs+1);
      if (strNE(string,"List"))
        av_store (array, j++, make_symbol ((char *) string)); 
      MLDisownSymbol (link, string);
      for (i = 0; i < nargs; i++) {
	av_store (array, j++, read_packet (link));
      }
      RETVAL = (SV *) newRV_noinc((SV*)array);
      break;
    }
  default:
    warn("Unknow packet type: %c\n", token);
  }
  return (RETVAL);
}

#line 128 "ematica.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 272 "ematica.c"

XS_EUPXS(XS_Math__ematica_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_constant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	int	arg = (int)SvIV(ST(1))
;
	double	RETVAL;
	dXSTARG;

	RETVAL = MLconstant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	SV *	RETVAL;
#line 133 "ematica.xs"
{
  char **argv = NULL;
  int argn;
  long merrno = 0;
  MLINK link;
  HV *self;
  New (14, argv, items, char *);

  if (!argv) croak ("Out of memory");

  for (argn = 0; argn < items; argn++) {
    argv[argn] = (char *) SvPV (ST (argn), PL_na);
  }

  link = MLOpenArgv (env, argv, argv + items, &merrno);

  Safefree(argv);

  if (merrno) error (merrno);
  MLActivate(link);

  self  = newHV();
  hv_store(self, "mlink", 5, newSViv((int) link), 0); 
  if (items == 1) 
    hv_store(self, "passive", 7, newSViv(1), 0); 
  RETVAL = sv_bless(newRV_noinc((SV*) self), gv_stashpv(CLASS,1));
}
#line 333 "ematica.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::DESTROY() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 167 "ematica.xs"
	if (!env) {
	  if (PL_dowarn) {
	    warn("Can not close link during global destruction!");
	  }
	} else {
	  if (link) MLClose(link); 
	}
#line 366 "ematica.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__ematica_END); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_END)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 179 "ematica.xs"
        MLDeinitialize(env);
        env = NULL;
#line 382 "ematica.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Math__ematica_ErrorMessage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_ErrorMessage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	kcharp_ct	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLErrorMessage() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLErrorMessage(link);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_EndPacket); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_EndPacket)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLEndPacket() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLEndPacket(link);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_Flush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_Flush)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLFlush() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLFlush(link);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_NewPacket); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_NewPacket)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLNewPacket() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLNewPacket(link);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_NextPacket); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_NextPacket)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	mlapi_packet	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLNextPacket() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLNextPacket(link);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_Ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_Ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLReady() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLReady(link);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_PutSymbol); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_PutSymbol)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "link, string");
    {
	MLINK	link;
	kcharp_ct	string = (kcharp_ct)SvPV_nolen(ST(1))
;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLPutSymbol() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLPutSymbol(link, string);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_PutString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_PutString)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "link, string");
    {
	MLINK	link;
	kcharp_ct	string = (kcharp_ct)SvPV_nolen(ST(1))
;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLPutString() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLPutString(link, string);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_PutInteger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_PutInteger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "link, integer");
    {
	MLINK	link;
	int_nt	integer = (int_nt)SvIV(ST(1))
;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLPutInteger() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLPutInteger(link, integer);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_PutDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_PutDouble)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "link, real");
    {
	MLINK	link;
	double_nt	real = (double_nt)SvNV(ST(1))
;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLPutDouble() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLPutDouble(link, real);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_PutFunction); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_PutFunction)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "link, name, nargs");
    {
	MLINK	link;
	kcharp_ct	name = (kcharp_ct)SvPV_nolen(ST(1))
;
	long_st	nargs = (long_st)SvIV(ST(2))
;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLPutFunction() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLPutFunction(link, name, nargs);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetNext); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetNext)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	mlapi_token	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetNext() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;

	RETVAL = MLGetNext(link);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetInteger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetInteger)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	int	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetInteger() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 251 "ematica.xs"
	if (!MLGetInteger(link, &RETVAL)) XSRETURN_UNDEF;
#line 745 "ematica.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetDouble)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	double	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetDouble() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 259 "ematica.xs"
	if (!MLGetDouble(link, &RETVAL)) XSRETURN_UNDEF;
#line 773 "ematica.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetString)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	kcharp_ct	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetString() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 267 "ematica.xs"
	if (!MLGetString(link, &RETVAL)) XSRETURN_UNDEF;
#line 801 "ematica.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 271 "ematica.xs"
        MLDisownString(link, RETVAL);
#line 805 "ematica.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetByteString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetByteString)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "link, ...");
    {
	MLINK	link;
	SV *	RETVAL;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetByteString() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 277 "ematica.xs"
        {         
            long                 spec = 0;
            const unsigned char *s;
            long                 n;
            if (items > 1) {
              spec = SvNV(ST(1));
            }
            if (!MLGetByteString(link, &s, &n, spec)) {
              XSRETURN_UNDEF;
            } else {
              RETVAL = newSVpvn(s, n);
              MLDisownByteString(link, s, n);
            }
        }
#line 844 "ematica.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetSymbol); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetSymbol)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
#line 298 "ematica.xs"
	kcharp_ct symname;
#line 862 "ematica.c"
	SV *	RETVAL;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetSymbol() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 300 "ematica.xs"
	if (!MLGetSymbol(link, &symname)) XSRETURN_UNDEF;
        RETVAL = make_symbol((char *)symname);
#line 876 "ematica.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
#line 305 "ematica.xs"
        MLDisownSymbol(link, symname);
#line 881 "ematica.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_GetFunction); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetFunction)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	MLINK	link;
#line 312 "ematica.xs"
	char *    name;
	long_st   nargs;
        SV *      symbol;
#line 901 "ematica.c"

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetFunction() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 316 "ematica.xs"
        if (!MLGetFunction(link, (kcharpp_ct) &name, &nargs)) {
          XSRETURN_UNDEF;
        }
        symbol = make_symbol(name);
        MLDisownSymbol(link, name);
        XPUSHs(sv_2mortal(symbol));
        if (GIMME_V == G_ARRAY) {
          XPUSHs(sv_2mortal(newSViv(nargs)));
          XSRETURN(2);
        } else {
          XSRETURN(1);
        }
#line 924 "ematica.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Math__ematica_GetRealList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_GetRealList)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	MLINK	link;
#line 333 "ematica.xs"
	doublep_nt	array;
	long_st         len;
        long_st         i;
#line 945 "ematica.c"

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::MLGetRealList() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 337 "ematica.xs"
        if (!MLGetRealList(link, &array, &len)) {
          XSRETURN_UNDEF;
        }
        EXTEND(sp, len);
        for (i=0;i<len;i++) {
          PUSHs(sv_2mortal(newSVnv(array[i])));
        }
        MLDisownRealList(link, array, len);
        XSRETURN(len);
#line 965 "ematica.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Math__ematica_symbol); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_symbol)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	name = ST(0)
;
#line 351 "ematica.xs"
        ST(0) = sv_2mortal(newRV_noinc(newSVsv(name)));
        sv_bless(ST(0), gv_stashpv(SYMNAME,1));
	XSRETURN(1);
#line 987 "ematica.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Math__ematica_PutToken); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_PutToken)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "link, elem, ...");
    {
	MLINK	link;
	SV *	elem = ST(1)
;
	mlapi_result	RETVAL;
	dXSTARG;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::PutToken() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 360 "ematica.xs"
	if (SvROK(elem)) {
          if (sv_isobject(elem) && sv_isa(elem, SYMNAME)) {
            if (items > 2) {
              RETVAL = MLPutFunction(link, SvPV(SvRV(elem), PL_na), SvIV(ST(2)));
            } else {
              RETVAL = MLPutSymbol(link, SvPV(SvRV(elem), PL_na));
            }
          } else {
            warn( "Math::ematica::PutScalar() -- elem is not a Math::ematica::symbol" );
            XSRETURN_UNDEF;
          }
        } else if (SvIOKp(elem)) {
          RETVAL = MLPutInteger(link, SvIV(elem));
        } else if (SvNOKp(elem)) {
          RETVAL = MLPutDouble(link, SvNV(elem));
        } else if (SvPOKp(elem)) {
          RETVAL = MLPutString(link, SvPV(elem, PL_na));
        } else {
          RETVAL = 0;
        }
#line 1036 "ematica.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Math__ematica_read_packet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Math__ematica_read_packet)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "link");
    {
	MLINK	link;
	SV *	RETVAL;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVHV)) {
            SV **ssv = hv_fetch((HV*) SvRV(ST(0)), "mlink", 5, 0);
            link = (MLINK)((ssv == NULL)? 0 : SvIV(*ssv));
	} else {
            warn( "Math::ematica::read_packet() -- link is not a blessed SV reference" );
            XSRETURN_UNDEF;
        }
;
#line 387 "ematica.xs"
	if ((RETVAL = read_packet(link)) == NULL) {
          XSRETURN_UNDEF;
        }
#line 1065 "ematica.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Math__ematica); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Math__ematica)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Math::ematica::constant", XS_Math__ematica_constant, file, "$$");
        (void)newXSproto_portable("Math::ematica::new", XS_Math__ematica_new, file, "$;@");
        (void)newXSproto_portable("Math::ematica::DESTROY", XS_Math__ematica_DESTROY, file, "$");
        (void)newXSproto_portable("Math::ematica::END", XS_Math__ematica_END, file, "");
        (void)newXSproto_portable("Math::ematica::ErrorMessage", XS_Math__ematica_ErrorMessage, file, "$");
        (void)newXSproto_portable("Math::ematica::EndPacket", XS_Math__ematica_EndPacket, file, "$");
        (void)newXSproto_portable("Math::ematica::Flush", XS_Math__ematica_Flush, file, "$");
        (void)newXSproto_portable("Math::ematica::NewPacket", XS_Math__ematica_NewPacket, file, "$");
        (void)newXSproto_portable("Math::ematica::NextPacket", XS_Math__ematica_NextPacket, file, "$");
        (void)newXSproto_portable("Math::ematica::Ready", XS_Math__ematica_Ready, file, "$");
        (void)newXSproto_portable("Math::ematica::PutSymbol", XS_Math__ematica_PutSymbol, file, "$$");
        (void)newXSproto_portable("Math::ematica::PutString", XS_Math__ematica_PutString, file, "$$");
        (void)newXSproto_portable("Math::ematica::PutInteger", XS_Math__ematica_PutInteger, file, "$$");
        (void)newXSproto_portable("Math::ematica::PutDouble", XS_Math__ematica_PutDouble, file, "$$");
        (void)newXSproto_portable("Math::ematica::PutFunction", XS_Math__ematica_PutFunction, file, "$$$");
        (void)newXSproto_portable("Math::ematica::GetNext", XS_Math__ematica_GetNext, file, "$");
        (void)newXSproto_portable("Math::ematica::GetInteger", XS_Math__ematica_GetInteger, file, "$");
        (void)newXSproto_portable("Math::ematica::GetDouble", XS_Math__ematica_GetDouble, file, "$");
        (void)newXSproto_portable("Math::ematica::GetString", XS_Math__ematica_GetString, file, "$");
        (void)newXSproto_portable("Math::ematica::GetByteString", XS_Math__ematica_GetByteString, file, "$;@");
        (void)newXSproto_portable("Math::ematica::GetSymbol", XS_Math__ematica_GetSymbol, file, "$");
        (void)newXSproto_portable("Math::ematica::GetFunction", XS_Math__ematica_GetFunction, file, "$");
        (void)newXSproto_portable("Math::ematica::GetRealList", XS_Math__ematica_GetRealList, file, "$");
        (void)newXSproto_portable("Math::ematica::symbol", XS_Math__ematica_symbol, file, "$");
        (void)newXSproto_portable("Math::ematica::PutToken", XS_Math__ematica_PutToken, file, "$$;@");
        (void)newXSproto_portable("Math::ematica::read_packet", XS_Math__ematica_read_packet, file, "$");

    /* Initialisation Section */

#line 121 "ematica.xs"
  env = MLInitialize(0);

#line 1132 "ematica.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}


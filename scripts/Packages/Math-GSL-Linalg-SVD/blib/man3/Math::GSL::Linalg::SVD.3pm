.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::GSL::Linalg::SVD 3pm"
.TH Math::GSL::Linalg::SVD 3pm "2020-03-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GSL::Linalg::SVD \- Perl extension with convenience methods for performing SVD and eigenvector decomp with the gsl C libraries.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::GSL::Linalg::SVD;
\&
\&    # Create object.
\&    my $svd = Math::GSL::Linalg::SVD\->new( { verbose => 1 } );
\&
\&    my $data = [ 
\&                    [qw/  9.515970281313E\-01  1.230695618728E\-01 \-1.652767938310E\-01 /],
\&                    [qw/ \-1.788010086499E\-01  3.654739881179E\-01  8.526964090247E\-02 /],
\&                    [qw/  4.156708817272E\-02  5.298288357316E\-02  7.130047145031E\-01 /],
\&               ];
\&
\&    # Load data.
\&    $svd\->load_data( { data => $data } );
\&
\&    # Perform singular value decomposition using the Golub\-Reinsch algorithm (this is the default \- see METHODS).
\&    # To perform eigen decomposition pass \*(Aqeign\*(Aq as algorithm argument \- see METHODS.
\&    $svd\->decompose( { algorithm => q{gd} } );
\&
\&    # Pass results \- see METHODS for more details.
\&    my ($S_vec_ref, $U_mat_ref, $V_mat_ref, $original_data_ref) = $svd\->results;
\&
\&    # Print elements of vector S.
\&    print qq{\enPrint diagonal elements in vector S\en};  
\&    for my $s (@{$S_vec_ref}) { print qq{$s, }; }
\&
\&    # Print elements of matrix U.
\&    print qq{\enPrint matrix U\en};  
\&    for my $r (0..$#{$U_mat_ref}) {
\&        for my $c (0..$#{$U_mat_ref\->[$r]}) { print qq{$U_mat_ref\->[$r][$c], } }; print qq{\en}; }
\&
\&    # Print elements of matrix V.
\&    print qq{\enPrint matrix V\en};  
\&    for my $r (0..$#{$V_mat_ref}) {
\&        for my $c (0..$#{$V_mat_ref\->[$r]}) { print qq{$V_mat_ref\->[$r][$c], } }; print qq{\en}; }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The singular value decomposition (\s-1SVD\s0) is an important factorization of a rectangular real matrix \- see
http://en.wikipedia.org/wiki/Singular_value_decomposition. Eigendecomposition is the factorization of a 
matrix into a canonical form, whereby the matrix is represented in terms of its eigenvalues and
eigenvectors \- see http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix. This module implements the 
\&\s-1SVD\s0 and Eigen decomposition routines of the The C \s-1GNU\s0 Scientific Library (\s-1GSL\s0). It provides simple convinience methods in the
upper-level Math::GSL::Linalg::SVD namespace to perform these operations. Alternatively, it also provides direct access
to the C routines in the Math::GSL::Linalg::SVD::Matrix, Math::GSL::Linalg::SVD::Vector and
Math::GSL::Linalg::SVD::Eigen namespaces \- see \s-1METHODS.\s0
.SH "METHODS"
.IX Header "METHODS"
This is a C\-Wrapper for the gsl \s-1SVD\s0 and Eigen decomp routines. Its provides two means of accessing them. First, a basic
OO-interface of convenience methods to allow simple use of the various sdv and eigen routines within the Math::GSL::Linalg::SVD namespaces. Second,
it allows you to use the various routines directly using an object interface for the various C structure types. These
exist within specific lower-level namespaces for convenience \- see below.
.SS "Math::GSL::Linalg::SVD"
.IX Subsection "Math::GSL::Linalg::SVD"
\fInew\fR
.IX Subsection "new"
.PP
Create a new Math:GSL::Linalg::SVD object.
.PP
.Vb 3
\&    my $svd = Math::GSL::Linalg::SVD\->new();
\&    # Pass verbose to turn on minimal messages.
\&    my $svd = Math::GSL::Linalg::SVD\->new( { verbose => 1 } );
.Ve
.PP
\fIload_data\fR
.IX Subsection "load_data"
.PP
Used for loading data into object. Data is fed as a reference to a LoL within an anonymous hash using the named argument
\&'data'.
.PP
.Vb 5
\&    $svd\->load_data( { data => [ 
\&                                    [qw/  9.515970281313E\-01 1.230695618728E\-01 /], 
\&                                    [qw/ \-1.788010086499E\-01 3.654739881179E\-01 /], 
\&                                    [qw/  4.156708817272E\-02  5.298288357316E\-02 /], 
\&                               ] } );
.Ve
.PP
\fIdecompose\fR
.IX Subsection "decompose"
.PP
Performs one of several different singular value decomposition algorithms on the loaded matrix (or computes eigenvalues
and eigenvectors) depending on argument passed with with 'algorithm' argument. To use the Golub-Reinsch algorithm 
implemented by \f(CW\*(C`gsl_linalg_SV_decomp\*(C'\fR pass 'gd'. To use the modified Golub-Reinsch algorithm implemented by 
\&\f(CW\*(C`gsl_linalg_SV_decomp_mod\*(C'\fR pass 'mod'. To use the one-sided Jacobi orthogonalization algorithm
implemented by \f(CW\*(C`gsl_linalg_SV_decomp_jacobi\*(C'\fR pass 'jacobi'. To perform the eigenvalue and eigenvector calculations
implemented by \f(CW\*(C`gsl_eigen_symmv\*(C'\fR pass 'eigen'. See
http://www.gnu.org/software/gsl/manual/html_node/Singular\-Value\-Decomposition.html for further details.
.PP
.Vb 5
\&    # Perform svd using the Golub\-Reinsch algorithm pass \*(Aqgd\*(Aq or nothing.
\&    $svd\->decompose();
\&    $svd\->decompose( { algorithm => q{mod} } );
\&    $svd\->decompose( { algorithm => q{jacobi} } );
\&    $eigen\->decompose( { algorithm => q{eigen} } );
.Ve
.PP
\fIresults\fR
.IX Subsection "results"
.PP
Used to access the results of the analysis. Called in \s-1LIST\s0 context. For svd an ordered \s-1LIST\s0 of the LoLs is returned
(corresponding to Vector S, Matrix U, Matrix V and Matrix A (see
http://www.gnu.org/software/gsl/manual/html_node/Singular\-Value\-Decomposition.html). See \s-1SYNOPSIS.\s0
.PP
.Vb 1
\&    my ($S_vec_ref, $U_mat_ref, $V_mat_ref, $original_data_ref) = $svd\->results;
.Ve
.PP
For eigen computation an ordered list of LoLs is returned corresponding to unordered eigenvalues, the eigenvectors (in
the same order as the eigenvalues) and the original data matrix. See
http://www.gnu.org/software/gsl/manual/html_node/Real\-Symmetric\-Matrices.html.
.PP
.Vb 1
\&    my ($e_val_ref, $e_vec_ref, $original_data_ref) = $eigen\->results;
\&
\&    # Print eigenvalues along with corresponding eigenvectors.
\&    for my $i (0..$#{$e_val_ref}) {
\&        print qq{\enEigenvalue: $e_val_ref\->[$i], };  
\&        print qq{\enEigenvector: }; 
\&        for my $vec_component (@{$e_vec_ref\->[$i]}) { print qq{$vec_component, }; }; print qq{\en}; }
.Ve
.SS "Math::GSL::Linalg::SVD::Matrix"
.IX Subsection "Math::GSL::Linalg::SVD::Matrix"
This namespace functions as an interface to the \f(CW\*(C`gsl_matrix\*(C'\fR C\-structure typedef.
.PP
\fInew\fR
.IX Subsection "new"
.PP
.Vb 4
\&    Name:           new
\&    Implements:     gsl_matrix_alloc
\&    Usage:          $gsl_matrix_pointer_as_perl_object = Math::GSL::Linalg::SVD::Matrix\->new;
\&    Returns:        pointer to a gsl_matrix type as Perl object
.Ve
.PP
\fIset_matrix\fR
.IX Subsection "set_matrix"
.PP
.Vb 4
\&    Name:           set_matrix
\&    Implements:     gsl_matrix_set
\&    Usage:          $gsl_matrix_pointer_as_perl_object\->set_matrix($row, $col, $double_number);
\&    Returns:
.Ve
.PP
\fIget_matrix\fR
.IX Subsection "get_matrix"
.PP
.Vb 4
\&    Name:           matrix_get
\&    Implements:     gsl_matrix_get
\&    Usage:          $gsl_matrix_pointer_as_perl_object\->set_matrix($row, $col);
\&    Returns:        scalar value
.Ve
.PP
\fISV_decomp\fR
.IX Subsection "SV_decomp"
.PP
.Vb 4
\&    Name:           SV_decomp
\&    Implements:     gsl_linalg_SV_decomp
\&    Usage:          $gsl_matrix_pointer_as_perl_object\->SV_decomp (...);
\&    Returns:
.Ve
.PP
\fISV_decomp_mod\fR
.IX Subsection "SV_decomp_mod"
.PP
.Vb 4
\&    Name:           SV_decomp_mod
\&    Implements:     gsl_linalg_SV_decomp_mod
\&    Usage:          $gsl_matrix_pointer_as_perl_object\->SV_decomp_mod (...);
\&    Returns:
.Ve
.PP
\fISV_decomp_jacobi\fR
.IX Subsection "SV_decomp_jacobi"
.PP
.Vb 4
\&    Name:           SV_decomp_jacobi
\&    Implements:     gsl_linalg_SV_decomp_jacobi
\&    Usage:          $gsl_matrix_pointer_as_perl_object\->SV_decomp_mod (...);
\&    Returns:
.Ve
.PP
\fIEigen_decomp\fR
.IX Subsection "Eigen_decomp"
.PP
.Vb 4
\&    Name:           Eigen_decomp
\&    Implements:     gsl_eigen_symmv
\&    Usage:          $gsl_matrix_pointer_as_perl_object\->Eigen_decomp (...);
\&    Returns:
.Ve
.SS "Math::GSL::Linalg::SVD::Vector"
.IX Subsection "Math::GSL::Linalg::SVD::Vector"
This namespace functions as an interface to the \f(CW\*(C`gsl_vector\*(C'\fR C\-structure typedef.
.PP
\fInew\fR
.IX Subsection "new"
.PP
.Vb 4
\&    Name:           new
\&    Implements:     gsl_vector_alloc
\&    Usage:          $gsl_vector_pointer_as_perl_object = Math::GSL::Linalg::SVD::Vector\->new;
\&    Returns:        pointer to gsl_vector as perl object
.Ve
.PP
\fIset_vector\fR
.IX Subsection "set_vector"
.PP
.Vb 4
\&    Name:           vector_set
\&    Implements:     gsl_vector_set
\&    Usage:          $gsl_vector_pointer_as_perl_object\->set_vector($row, $col, $double_number);
\&    Returns:
.Ve
.PP
\fIget_vector\fR
.IX Subsection "get_vector"
.PP
.Vb 4
\&    Name:           vector_get
\&    Implements:     gsl_vector_get
\&    Usage:          $gsl_vector_pointer_as_perl_object\->set_vector($row, $col)
\&    Returns:        scalar value
.Ve
.SS "Math::GSL::Linalg::SVD::Eigen"
.IX Subsection "Math::GSL::Linalg::SVD::Eigen"
This namespace functions as an interface to the \f(CW\*(C`gsl_eigen_symmv_workspace\*(C'\fR C\-structure typedef used as workspace for
the eigen decomposition routines of the gsl library.
.PP
\fInew\fR
.IX Subsection "new"
.PP
.Vb 4
\&    Name:           new
\&    Implements:     gsl_eigen_symmv_alloc
\&    Usage:          $gsl_vector_pointer_as_perl_object = Math::GSL::Linalg::SVD::vector\->new;
\&    Returns:        pointer to gsl_eigen_symmv type as perl object
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel S. T. Hughes <dsth@cpan.org>
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2009, Daniel S. T. Hughes <dsth@cantab.net>. All rights reserved.
.PP
This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by
applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the
software \*(L"as is\*(R" without warranty of any kind, either expressed or implied, including, but not limited to, the
implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and
performance of the software is with you. Should the software prove defective, you assume the cost of all necessary
servicing, repair, or correction.
.PP
In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other
party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for
damages, including any general, special, incidental, or consequential damages arising out of the use or inability
to use the software (including but not limited to loss of data or data being rendered inaccurate or losses
sustained by you or third parties or a failure of the software to operate with any other software), even if
such holder or other party has been advised of the possibility of such damages.
Dr Daniel S. T. Hughes, <dsth@>
